

```markdown
---
title: "Xmer Network Analysis"
author: "Brock Kingstad-Bakke"
date: "`r format(Sys.Date(), '%Y-%m-%d')`"
output: html_document
---

# Introduction

This document demonstrates a reproducible workflow for analyzing sequences, extracting x-mers, clustering, and visualizing results as a network. The code is organized into logical steps, and metadata parsing can be done in either fully automatic or manual modes.

## Prerequisites

- Ensure that you have created a Conda environment and installed the necessary packages as described in the project's README.
- Source control and versioning managed through Git and GitHub.
- For GPU computing features, ensure appropriate drivers and hardware support.

---

# Global Setup

Below are global variables and constants that define parameters such as x-mer length and thresholds for filtering. Modify these as needed for your analysis.

```{r global-setup, include=TRUE}
#############################################
# Global Variables and Constants
#############################################

cpu_gpu_full = "gpu"      # Choice for full dataset computations (gpu or cpu)
cpu_gpu_reps = "cpu"      # Choice for representative subset computations
xmer_l = 9                # Length of the x-mers used
unique_threshhold = 3     # Minimum number of sequences an x-mer must appear in
fasta_file <- "514479539277-npgood.fasta"

external_sequence_info <- data.frame(
  Header = c(
    "Mosaic NP",
    "H1N1 CA04",
    "H1N1 PR8",
    "H3N2 Aichi",
    "H5N1 A/Texas/37/2024",
    "H3N2 A/Wisconsin/2007",
    "H5N1 A/Vietnam/2004"
  ),
  Sequence = c(
    "MASQGTKRSYEQMETGGERQNATEIRASVGRMVGGIGRFYIQMCTELKLSDYEGRLIQNSITIERMVLSAFDERRNKYLEEHPSAGKDPKKTGGPIYRRRDGKWMRELILYDKEEIRRIWRQANNGEDATAGLTHLMIWHSNLNDATYQRTRALVRTGMDPRMCSLMQGSTLPRRSGAAGAAVKGVGTMVMELIRMIKRGINDRNFWRGENGRRTRIAYERMCNILKGKFQTAAQRAMMDQVRESRNPGNAEIEDLIFLARSALILRGSVAHKSCLPACVYGLAVASGYDFEREGYSLVGIDPFRLLQNSQVYSLIRPNENPAHKSQLVWMACHSAAFEDLRVSSFIRGTRVVPRGQLSTRGVQIASNENMETMDSSTLELRSRYWAIRTRSGGNTNQQRASAGQISVQPTFSVQRNLPFERATIMAAFTGNTEGRTSDMRTEIIRMMESARPEDVSFQGRGVFELSDEKATNPIVPSFDMSNEGSYFFGDNAEEYDNK",
    "MASQGTKRSYEQMETGGERQDATEIRASVGRMIGGIGRFYIQMCTELKLSDYDGRLIQNSITIERMVLSAFDERRNKYLEEHPSAGKDPKKTGGPIYRRVDGKWMRELILYDKEEIRRVWRQANNGEDATAGLTHIMIWHSNLNDATYQRTRALVRTGMDPRMCSLMQGSTLPRRSGAAGAAVKGVGTIAMELIRMIKRGINDRNFWRGENGRRTRVAYERMCNILKGKFQTAAQRAMMDQVRESRNPGNAEIEDLIFLARSALILRGSVAHKSCLPACVYGLAVASGHDFEREGYSLVGIDPFKLLQNSQVVSLMRPNENPAHKSQLVWMACHSAAFEDLRVSSFIRGKKVIPRGKLSTRGVQIASNENVETMDSNTLELRSRYWAIRTRSGGNTNQQKASAGQISVQPTFSVQRNLPFERATVMAAFSGNNEGRTSDMRTEVIRMMESAKPEDLSFQGRGVFELSDEKATNPIVPSFDMSNEGSYFFGDNAEEYDS",
    "MASQGTKRSYEQMETDGERQNATEIRASVGKMIGGIGRFYIQMCTELKLSDYEGRLIQNSLTIERMVLSAFDERRNKYLEEHPSAGKDPKKTGGPIYRRVNGKWMRELILYDKEEIRRIWRQANNGDDATAGLTHMMIWHSNLNDATYQRTRALVRTGMDPRMCSLMQGSTLPRRSGAAGAAVKGVGTMVMELVRMIKRGINDRNFWRGENGRKTRIAYERMCNILKGKFQTAAQKAMMDQVRESRNPGNAEFEDLTFLARSALILRGSVAHKSCLPACVYGPAVASGYDFEREGYSLVGIDPFRLLQNSQVYSLIRPNENPAHKSQLVWMACHSAAFEDLRVLSFIKGTKVLPRGKLSTRGVQIASNENMETMESSTLELRSRYWAIRTRSGGNTNQQRASAGQISIQPTFSVQRNLPFDRTTIMAAFNGNTEGRTSDMRTEIIRMMESARPEDVSFQGRGVFELSDEKAASPIVPSFDMSNEGSYFFGDNAEEYDN",
    "MASQGTKRSYEQMETDGERQNATEIRASVGKMIDGIGRFYIQMCTELKLSDYEGRLIQNSLTIERMVLSAFDERRNKYLEEHPSAGKDPKKTGGPIYKRVDRKWMRELVLYDKEEIRRIWRQANNGDDATAGLTHMMIWHSNLNDTTYQRTRALVRTGMDPRMCSLMQGSTLPRRSGAAGAAVKGVGTMVMELIRMIKRGINDRNFWRGENGRKTRSAYERMCNILKGKFQTAAQRAMMDQVRESRNPGNAEIEDLIFLARSALILRGSVAHKSCLPACVYGPAVASGYDFEKEGYSLVGIDPFKLLQNSQVYSLIRPNENPAHKSQLVWMACNSAAFEDLRVLSFIRGTKVSPRGKLSTRGVQIASNENMDAMESSTLELRSRYWAIRTRSGGNTNQQRASAGQISVQPAFSVQRNLPFDKPTIMAAFTGNTEGRTSDMRAEIIRMMEGAKPEEMSFQGRGVFELSDERAANPIVPSFDMSNEGSYFFGDNAEEYDN",
    "MASQGTKRSYEQMETGGERQNATEIRASVGRMVGGIGRFYIQMCTELKLSDHEGRLIQNSITIERMVLSAFDERRNKYLEEHPSAGKDPKKTGGPIYRRRDGKWMRELILYDKEEIRRIWRQANNGEDATAGLTHLMIWHSNLNDATYQRTRALVRTGMDPRMCSLMQGSTLPRRSGAAGAAVKGVGTMVMELIRMIKRGINDRNFWRGENGRRTRIAYERMCNILKGKFQTAAQRAMMDQVRESRNPGNAEIEDLIFLARSALILRGSVAHKSCLPACVYGLAVASGYDFEREGYSLVGIDPFRLLQNSQVFSLIRPNENPAHKSQLVWMACHSAAFEDLRVSSFIRGTRVVPRGQLSTRGVQIASNENMETMDSSTLELRSRYWAIRTRSGGNTNQQRASAGQISVQPTFSVQRNLPFERATIMAAFTGNTEGRTSDMRTEIIRMMENARPEDVSFQGRGVFELSDEKATNPIVPSFDMNNEGSYFFGDNAEEYDN",
    "MASQGTKRSYEQMETDGDRQNATEIRASVGKMIDGIGRFYIQMCTELKLSDHEGRLIQNSLTIEKMVLSAFDERRNKYLEEHPSAGKDPKKTGGPIYRRVDGKWMRELVLYDKEEIRRIWRQANNGEDATSGLTHIMIWHSNLNDATYQRTRALVRTGMDPRMCSLMQGSTLPRRSGAAGAAVKGIGTMVMELIRMVKRGINDRNFWRGENGRKTRSAYERMCNILKGKFQTAAQRAMVDQVRESRNPGNAEIEDLIFLARSALILRGSVAHKSCLPACAYGPAVSSGYNFEKEGYSLVGIDPFKLLQNSQIYSLIRPNENPAHKSQLVWMACHSAAFEDLRLLSFIRGTKVSPRGKLSTRGVQIASNENMDNMGSSTLELRSGYWAIRTRSGGNTNQQRASAGQTSVQPTFSVQRNLPFEKSTIMAAFTGNTEGRTSDMRAEIIRMMEGAKPEEVSFRGRGVFELSDEKATNPIVPSFDMSNEGSYFFGDNAKEYDN",
    "MASQGTKRSYEQMETGGERQNATEIRASVGRMVSGIGRFYIQMCTELKLSDYEGRLIQNSITIERMVLSAFDERRNRYLEEHPSAGKDPKKTGGPIYRRRDGKWVRELILYDKEEIRRIWRQANNGEDATAGLTHLMIWHSNLNDATYQRTRALVRTGMDPRMCSLMQGSTLPRRSGAAGAAVKGVGTMVMELIRMIKRGINDRNFWRGENGRRTRIAYERMCNILKGKFQTAAQRAMMDQVRESRNPGNAEIEDLIFLARSALILRGSVAHKSCLPACVYGLAVASGYDFEREGYSLVGIDPFRLLQNSQVFSLIRPNENPAHKSQLVWMACHSAAFEDLRVSSFIRGTRVVPRGQLSTRGVQIASNENMEAMDSNTLELRSRYWAIRTRSGGNTNQQKASAGQISVQPTFSVQRNLPFERATIMAAFTGNTEGRTSDMRTEIIRMMESARPEDVSFQGRGVFELSDEKATNPIVPSFDMNNEGSYFFGDNAEEYDN"
  ),
  stringsAsFactors = FALSE
)

external_sequences_to_prioritize <- c(
  "H1N1 CA04",
  "H1N1 PR8",
  "H3N2 Aichi",
  "H5N1 A/Texas/37/2024",
  "H3N2 A/Wisconsin/2007",
  "H5N1 A/Vietnam/2004",
  "Mosaic NP"
)

manual_years <- data.frame(
  Strain_Name = c(
    "A/chicken/Taiwan/0320/02)H6N1)",
    "A/common murre/Oregon/20361-002/2007Segment: 1",
    "A/Georgia/JY2/unknown",
    "A/PAL/unknown",
    "A/Puerto Rico/8/34/Mount Sinai",
    "A/Uganda/MUWRP-016/"
  ),
  Year = c(2002, 2007, 1934, 1934, 1934, 2016),
  stringsAsFactors = FALSE
)
```

---

# Step 1: Read and Filter Sequences

This function reads sequences from a specified FASTA file, filters out any with invalid amino acids, and returns a filtered data frame.

```{r step1-read-filter}
df_filtered <- read_and_filter_sequences(fasta_file)
```

---

# Step 2: Extract and Filter x-mers

This step extracts all x-mers (subsequences of length `xmer_l`) from each sequence, and filters out those that appear too infrequently (below `unique_threshhold`).

```{r step2-extract-xmers}
ninemer_results <- extract_and_filter_ninemers(df_filtered)
sequence_presence_matrix <- ninemer_results$matrix
unique_ninemers <- ninemer_results$unique_ninemers
```

---

# Step 3: Add External Sequences

We incorporate additional reference or external sequences into the sequence presence matrix for comparison and clustering.

```{r step3-add-external}
sequence_presence_matrix_with_external <- add_external_sequences(sequence_presence_matrix, unique_ninemers, external_sequence_info)
```

---

# Step 4: Parse Metadata

**Instructions:**

- **Default Mode:** Metadata parsing uses predefined rules.
- **Manual Mode:** Prompts you for separators and optionally allows you to define custom field names.

Here we run the parser in default mode for demonstration.

```{r step4-parse-metadata}
df_with_metadata <- parse_metadata(df_filtered) # default mode

# If manual mode is desired:
# df_with_metadata <- parse_metadata(df_filtered, manual = TRUE)
```

---

# Step 5: Extract and Assign Year

Parses strain names to extract the year of isolation. For entries without a valid year, we use manually provided corrections.

```{r step5-assign-years}
df_with_metadata <- assign_years(df_with_metadata, manual_years)
```

---

# Step 6: Compute Similarity and Perform Clustering

Calculates a Jaccard similarity matrix (either CPU or GPU-based) and performs hierarchical clustering to group similar sequences.

```{r step6-clustering}
cluster_results <- compute_similarity_and_cluster(sequence_presence_matrix_with_external, method = cpu_gpu_full)
df_clusters <- cluster_results$df_clusters
```

---

# Step 7: Select Representative Sequences

From each cluster, select a representative sequence. External sequences are prioritized if present in a cluster.

```{r step7-select-representatives}
representative_sequences <- select_representatives(df_clusters, external_sequences_to_prioritize)
```

---

# Step 8: Calculate Network (Representatives)

Compute a similarity network of the representative sequences and generate an adjacency matrix.

```{r step8-network}
g_representative_final <- calculate_network(sequence_presence_matrix_with_external, representative_sequences, method = cpu_gpu_reps)
```

---

# Step 9: Merge Host and Subtype

Merge host and subtype data into the network nodes based on parsed metadata and external reference sequences.

```{r step9-merge-host-subtype}
g_representative_final <- merge_host_subtype(g_representative_final, df_with_metadata, representative_sequences)
```

---

# Step 10: Plot and Save

Visualize the resulting network as an SVG file, labeling nodes by host category, subtype, or reference status.

```{r step10-plot-save}
plot_and_save_graph(g_representative_final, "network_graph1.svg")
cat("All steps completed. The output 'network_graph1.svg' has been saved.\n")
```
